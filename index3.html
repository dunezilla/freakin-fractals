<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Raymarching Discovery</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #c {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease;
            pointer-events: none;
            font-size: 14px;
            letter-spacing: 1px;
        }

        #ui.dim {
            opacity: 0.1;
        }

        #fps {
            font-family: monospace;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <div id="ui">
        <div id="fps">FPS: --</div>
        <div style="margin-top: 5px; opacity: 0.7; font-size: 10px;">MOUSE TO FLY</div>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            document.body.innerHTML = '<div style="padding:20px">WebGL2 not supported on this browser.</div>';
        }

        // ------------------------------------------------------------
        // Shader Source
        // ------------------------------------------------------------
        const vert = `#version 300 es
    in vec2 aPos;
    void main() {
        gl_Position = vec4(aPos, 0.0, 1.0);
    }`;

        const frag = `#version 300 es
    precision highp float;
    uniform float uTime;
    uniform vec2 uResolution;
    uniform vec2 uMouse;
    out vec4 outColor;

    float map(vec3 p) {
        vec3 n = vec3(0, 1, 0);
        float k1 = 1.9;
        float k2 = (sin(p.x * k1) + sin(p.z * k1)) * 0.8;
        float k3 = (sin(p.y * k1) + sin(p.z * k1)) * 0.8;
        float w1 = 4.0 - dot(abs(p), normalize(n)) + k2;
        float w2 = 4.0 - dot(abs(p), normalize(n.yzx)) + k3;
        float s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.0) - 1.0) - 0.2;
        float s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.0) - 1.0) - 0.2;
        return min(w1, min(w2, min(s1, s2)));
    }

    vec2 rot(vec2 p, float a) {
        return vec2(
            p.x * cos(a) - p.y * sin(a),
            p.x * sin(a) + p.y * cos(a)
        );
    }

    void main() {
        float time = uTime;
        vec2 uv = (gl_FragCoord.xy / uResolution.xy) * 2.0 - 1.0;
        uv.x *= uResolution.x / uResolution.y;

        // Interaction: Use mouse to offset direction ("flying")
        vec2 m = (uMouse / uResolution.xy) * 2.0 - 1.0;
        
        vec3 dir = normalize(vec3(uv + m * 0.5, 1.0));
        
        // Auto rotation + Mouse influence
        dir.xz = rot(dir.xz, time * 0.15 + m.x * 0.5);
        dir = dir.yzx;
        dir.xz = rot(dir.xz, time * 0.1 + m.y * 0.5);
        dir = dir.yzx;

        vec3 pos = vec3(0.0, 0.0, time * 1.2);
        
        float t = 0.0;
        float tt = 0.0;
        for(int i = 0; i < 90; i++) {
            tt = map(pos + dir * t);
            if(tt < 0.001) break;
            t += tt * 0.5;
            if(t > 30.0) break;
        }

        vec3 ip = pos + dir * t;
        
        // Dynamic coloring based on depth and position
        float hue = time * 0.1 + t * 0.05;
        vec3 baseCol = 0.5 + 0.5 * cos(vec3(0, 2, 4) + hue);
        
        vec3 col = baseCol * (1.0 / (1.0 + t * t * 0.01));
        col *= sqrt(t * 0.1);
        
        // Fog / Atmospheric depth
        float fog = exp(-t * 0.07);
        vec3 finalCol = col * fog + (1.0 - fog) * vec3(0.01, 0.02, 0.05);

        // Final coloring with logic from the provided snippet + enhancements
        outColor = vec4(finalCol + abs(dir) * col * 0.5 + max(0.0, map(ip - 0.1) - tt), 1.0);
        outColor.rgb = pow(outColor.rgb, vec3(0.8)); // slightly more contrast
    }`;

        // ------------------------------------------------------------
        // Initialize WebGL
        // ------------------------------------------------------------
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vShader = createShader(gl, gl.VERTEX_SHADER, vert);
        const fShader = createShader(gl, gl.FRAGMENT_SHADER, frag);
        const program = gl.createProgram();
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const posLoc = gl.getAttribLocation(program, 'aPos');
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(program, 'uTime');
        const uRes = gl.getUniformLocation(program, 'uResolution');
        const uMouse = gl.getUniformLocation(program, 'uMouse');

        // ------------------------------------------------------------
        // Input Handling
        // ------------------------------------------------------------
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let targetMouseX = mouseX, targetMouseY = mouseY;

        window.addEventListener('pointermove', e => {
            targetMouseX = e.clientX;
            targetMouseY = e.clientY;
            heartbeat();
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // ------------------------------------------------------------
        // Animation Loop
        // ------------------------------------------------------------
        let fpsCounter = 0, fpsTime = performance.now();
        const ui = document.getElementById('ui');
        const fpsLabel = document.getElementById('fps');

        function loop(now) {
            // Easing for mouse
            mouseX += (targetMouseX - mouseX) * 0.05;
            mouseY += (targetMouseY - mouseY) * 0.05;

            gl.uniform1f(uTime, now * 0.001);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform2f(uMouse, mouseX, canvas.height - mouseY);

            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // FPS tracking
            fpsCounter++;
            if (now - fpsTime >= 1000) {
                fpsLabel.textContent = `FPS: ${fpsCounter}`;
                fpsCounter = 0;
                fpsTime = now;
            }

            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        // UI dimming
        let dimTO;
        function heartbeat() {
            ui.classList.remove('dim');
            clearTimeout(dimTO);
            dimTO = setTimeout(() => ui.classList.add('dim'), 3000);
        }
        heartbeat();
    </script>
</body>

</html>